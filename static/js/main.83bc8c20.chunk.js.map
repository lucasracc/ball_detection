{"version":3,"sources":["index.js"],"names":["TFWrapper","model","detect","input","batched","tf","fromPixels","expandDims","height","shape","width","executeAsync","then","result","scores","dataSync","boxes","dispose","_calculateMaxScores","numBoxes","numClasses","maxes","classes","i","max","Number","MIN_VALUE","index","j","calculateMaxScores","_calculateMaxScores2","Object","C_Users_lucas_r_abreu_Desktop_fei_object_detection_react_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__","maxScores","prevBackend","indexTensor","boxes2","nonMaxSuppression","indexes","count","length","objects","bbox","minY","minX","maxY","maxX","push","class","score","buildDetectedObjects","App","videoRef","React","createRef","canvasRef","detectFrame","video","labels","predictions","_this","renderPredictions","requestAnimationFrame","ctx","current","getContext","clearRect","canvas","font","textBaseline","forEach","prediction","x","y","label","parseInt","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","textHeight","fillRect","fillText","_this2","this","navigator","mediaDevices","getUserMedia","webCamPromise","audio","facingMode","stream","window","srcObject","Promise","resolve","_","onloadedmetadata","modelPromise","MODEL_URL","labelsPromise","fetch","data","json","all","values","_values","catch","error","console","react__WEBPACK_IMPORTED_MODULE_6___default","a","createElement","className","autoPlay","playsInline","muted","ref","Component","rootElement","document","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.83bc8c20.chunk.js","sourcesContent":["import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport * as tf from '@tensorflow/tfjs'\r\nimport './styles.css'\r\n\r\nconst MODEL_URL = process.env.PUBLIC_URL + '/model_web/'\r\nconst LABELS_URL = MODEL_URL + 'labels.json'\r\nconst MODEL_JSON = MODEL_URL + 'model.json'\r\n\r\nconst TFWrapper = model => {\r\n  const calculateMaxScores = (scores, numBoxes, numClasses) => {\r\n    const maxes = []\r\n    const classes = []\r\n    for (let i = 0; i < numBoxes; i++) {\r\n      let max = Number.MIN_VALUE\r\n      let index = -1\r\n      for (let j = 0; j < numClasses; j++) {\r\n        if (scores[i * numClasses + j] > max) {\r\n          max = scores[i * numClasses + j]\r\n          index = j\r\n        }\r\n      }\r\n      maxes[i] = max\r\n      classes[i] = index\r\n    }\r\n    return [maxes, classes]\r\n  }\r\n\r\n  const buildDetectedObjects = (\r\n    width,\r\n    height,\r\n    boxes,\r\n    scores,\r\n    indexes,\r\n    classes\r\n  ) => {\r\n    const count = indexes.length\r\n    const objects = []\r\n    for (let i = 0; i < count; i++) {\r\n      const bbox = []\r\n      for (let j = 0; j < 4; j++) {\r\n        bbox[j] = boxes[indexes[i] * 4 + j]\r\n      }\r\n      const minY = bbox[0] * height\r\n      const minX = bbox[1] * width\r\n      const maxY = bbox[2] * height\r\n      const maxX = bbox[3] * width\r\n      bbox[0] = minX\r\n      bbox[1] = minY\r\n      bbox[2] = maxX - minX\r\n      bbox[3] = maxY - minY\r\n      objects.push({\r\n        bbox: bbox,\r\n        class: classes[indexes[i]],\r\n        score: scores[indexes[i]]\r\n      })\r\n    }\r\n    return objects\r\n  }\r\n\r\n  const detect = input => {\r\n    const batched = tf.tidy(() => {\r\n      const img = tf.browser.fromPixels(input)\r\n      // Reshape to a single-element batch so we can pass it to executeAsync.\r\n      return img.expandDims(0)\r\n    })\r\n\r\n    const height = batched.shape[1]\r\n    const width = batched.shape[2]\r\n\r\n    return model.executeAsync(batched).then(result => {\r\n      const scores = result[0].dataSync()\r\n      const boxes = result[1].dataSync()\r\n\r\n      // clean the webgl tensors\r\n      batched.dispose()\r\n      tf.dispose(result)\r\n\r\n      const [maxScores, classes] = calculateMaxScores(\r\n        scores,\r\n        result[0].shape[1],\r\n        result[0].shape[2]\r\n      )\r\n\r\n      const prevBackend = tf.getBackend()\r\n      // run post process in cpu\r\n      tf.setBackend('cpu')\r\n      const indexTensor = tf.tidy(() => {\r\n        const boxes2 = tf.tensor2d(boxes, [\r\n          result[1].shape[1],\r\n          result[1].shape[3]\r\n        ])\r\n        return tf.image.nonMaxSuppression(\r\n          boxes2,\r\n          maxScores,\r\n          20, // maxNumBoxes\r\n          0.5, // iou_threshold\r\n          0.5 // score_threshold\r\n        )\r\n      })\r\n      const indexes = indexTensor.dataSync()\r\n      indexTensor.dispose()\r\n      // restore previous backend\r\n      tf.setBackend(prevBackend)\r\n\r\n      return buildDetectedObjects(\r\n        width,\r\n        height,\r\n        boxes,\r\n        maxScores,\r\n        indexes,\r\n        classes\r\n      )\r\n    })\r\n  }\r\n  return {\r\n    detect: detect\r\n  }\r\n}\r\n\r\nclass App extends React.Component {\r\n  videoRef = React.createRef()\r\n  canvasRef = React.createRef()\r\n\r\n  componentDidMount() {\r\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n      const webCamPromise = navigator.mediaDevices\r\n        .getUserMedia({\r\n          audio: false,\r\n          video: {\r\n            facingMode: 'user'\r\n          }\r\n        })\r\n        .then(stream => {\r\n          window.stream = stream\r\n          this.videoRef.current.srcObject = stream\r\n          return new Promise((resolve, _) => {\r\n            this.videoRef.current.onloadedmetadata = () => {\r\n              resolve()\r\n            }\r\n          })\r\n        })\r\n\r\n      const modelPromise = tf.loadGraphModel(MODEL_JSON)\r\n      const labelsPromise = fetch(LABELS_URL).then(data => data.json())\r\n      Promise.all([modelPromise, labelsPromise, webCamPromise])\r\n        .then(values => {\r\n          const [model, labels] = values\r\n          this.detectFrame(this.videoRef.current, model, labels)\r\n        })\r\n        .catch(error => {\r\n          console.error(error)\r\n        })\r\n    }\r\n  }\r\n\r\n  detectFrame = (video, model, labels) => {\r\n    TFWrapper(model)\r\n      .detect(video)\r\n      .then(predictions => {\r\n        this.renderPredictions(predictions, labels)\r\n        requestAnimationFrame(() => {\r\n          this.detectFrame(video, model, labels)\r\n        })\r\n      })\r\n  }\r\n\r\n  renderPredictions = (predictions, labels) => {\r\n    const ctx = this.canvasRef.current.getContext('2d')\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n    // Font options.\r\n    const font = '16px sans-serif'\r\n    ctx.font = font\r\n    ctx.textBaseline = 'top'\r\n    predictions.forEach(prediction => {\r\n      const x = prediction.bbox[0]\r\n      const y = prediction.bbox[1]\r\n      const width = prediction.bbox[2]\r\n      const height = prediction.bbox[3]\r\n      const label = labels[parseInt(prediction.class)]\r\n      // Draw the bounding box.\r\n      ctx.strokeStyle = '#00FFFF'\r\n      ctx.lineWidth = 4\r\n      ctx.strokeRect(x, y, width, height)\r\n      // Draw the label background.\r\n      ctx.fillStyle = '#00FFFF'\r\n      const textWidth = ctx.measureText(label).width\r\n      const textHeight = parseInt(font, 10) // base 10\r\n      ctx.fillRect(x, y, textWidth + 4, textHeight + 4)\r\n    })\r\n\r\n    predictions.forEach(prediction => {\r\n      const x = prediction.bbox[0]\r\n      const y = prediction.bbox[1]\r\n      const label = labels[parseInt(prediction.class)]\r\n      // Draw the text last to ensure it's on top.\r\n      ctx.fillStyle = '#000000'\r\n      ctx.fillText(label, x, y)\r\n    })\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <video\r\n          className=\"size\"\r\n          autoPlay\r\n          playsInline\r\n          muted\r\n          ref={this.videoRef}\r\n          width=\"600\"\r\n          height=\"500\"\r\n        />\r\n        <canvas\r\n          className=\"size\"\r\n          ref={this.canvasRef}\r\n          width=\"600\"\r\n          height=\"500\"\r\n        />\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nconst rootElement = document.getElementById('root')\r\nReactDOM.render(<App />, rootElement)\r\n"],"sourceRoot":""}